{"version":3,"file":"index.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/components/FileSelector.scss?8e83","webpack:///./src/components/TextButton.scss?9052","webpack:///./src/components/IconButton.scss?8012","webpack:///./src/components/ImporterFrame.scss?9c61","webpack:///./src/components/FormatErrorMessage.scss?f883","webpack:///./src/components/FormatRawPreview.scss?570d","webpack:///./src/components/FormatDataRowPreview.scss?ca69","webpack:///./src/components/FormatPreview.scss?1ab3","webpack:///./src/components/ColumnDragCard.scss?e301","webpack:///./src/components/ColumnDragObject.scss?86b4","webpack:///./src/components/ColumnDragSourceArea.scss?988c","webpack:///./src/components/ColumnDragTargetArea.scss?b79f","webpack:///./src/components/ProgressDisplay.scss?6ad0","webpack:///./src/components/Importer.scss?f3ca","webpack:///./src/components/ImporterProps.ts","webpack:///./src/components/ColumnPreview.tsx","webpack:///./src/components/FileSelector.tsx","webpack:///./src/components/parser.ts","webpack:///./src/components/TextButton.tsx","webpack:///./src/components/IconButton.tsx","webpack:///./src/components/ImporterFrame.tsx","webpack:///./src/components/FormatErrorMessage.tsx","webpack:///./src/components/FormatRawPreview.tsx","webpack:///./src/components/FormatDataRowPreview.tsx","webpack:///./src/components/FormatPreview.tsx","webpack:///./src/components/ColumnDragState.tsx","webpack:///./src/components/ColumnDragCard.tsx","webpack:///./src/components/ColumnDragObject.tsx","webpack:///./src/components/ColumnDragSourceArea.tsx","webpack:///./src/components/ColumnDragTargetArea.tsx","webpack:///./src/components/ColumnPicker.tsx","webpack:///./src/components/ProgressDisplay.tsx","webpack:///./src/components/Importer.tsx","webpack:///./src/index.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","export {};\n","// spreadsheet-style column code computation (A, B, ..., Z, AA, AB, ..., etc)\nexport function generateColumnCode(value) {\n    // ignore dummy index\n    if (value < 0) {\n        return '';\n    }\n    // first, determine how many base-26 letters there should be\n    // (because the notation is not purely positional)\n    let digitCount = 1;\n    let base = 0;\n    let next = 26;\n    while (next <= value) {\n        digitCount += 1;\n        base = next;\n        next = next * 26 + 26;\n    }\n    // then, apply normal positional digit computation on remainder above base\n    let remainder = value - base;\n    const digits = [];\n    while (digits.length < digitCount) {\n        const lastDigit = remainder % 26;\n        remainder = Math.floor((remainder - lastDigit) / 26); // applying floor just in case\n        // store ASCII code, with A as 0\n        digits.unshift(65 + lastDigit);\n    }\n    return String.fromCharCode.apply(null, digits);\n}\n// prepare spreadsheet-like column display information for given raw data preview\nexport function generatePreviewColumns(firstRows, hasHeaders) {\n    const columnStubs = [...new Array(firstRows[0].length)];\n    return columnStubs.map((empty, index) => {\n        const values = firstRows.map((row) => row[index] || '');\n        const headerValue = hasHeaders ? values.shift() : undefined;\n        return {\n            index,\n            header: headerValue,\n            values\n        };\n    });\n}\n","import React, { useCallback, useRef } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport './FileSelector.scss';\nexport const FileSelector = ({ onSelected }) => {\n    const onSelectedRef = useRef(onSelected);\n    onSelectedRef.current = onSelected;\n    const dropHandler = useCallback((acceptedFiles) => {\n        // silently ignore if nothing to do\n        if (acceptedFiles.length < 1) {\n            return;\n        }\n        const file = acceptedFiles[0];\n        onSelectedRef.current(file);\n    }, []);\n    const { getRootProps, getInputProps, isDragActive } = useDropzone({\n        onDrop: dropHandler\n    });\n    return (React.createElement(\"div\", Object.assign({ className: \"CSVImporter_FileSelector\", \"data-active\": !!isDragActive }, getRootProps()),\n        React.createElement(\"input\", Object.assign({}, getInputProps())),\n        isDragActive ? (React.createElement(\"span\", null, \"Drop CSV file here...\")) : (React.createElement(\"span\", null, \"Drag-and-drop CSV file here, or click to select in folder\"))));\n};\n","import Papa from 'papaparse';\nimport { ReadableWebToNodeStream } from 'readable-web-to-node-stream';\nconst BOM_CODE = 65279; // 0xFEFF\nexport const PREVIEW_ROW_COUNT = 5;\nexport function parsePreview(file, customConfig) {\n    // wrap synchronous errors in promise\n    return new Promise((resolve) => {\n        let firstChunk = null;\n        let firstWarning = undefined;\n        const rowAccumulator = [];\n        function reportSuccess() {\n            // PapaParse normally complains first anyway, but might as well flag it\n            if (rowAccumulator.length === 0) {\n                return {\n                    parseError: new Error('File is empty')\n                };\n            }\n            // remember whether this file has only one line\n            const isSingleLine = rowAccumulator.length === 1;\n            // fill preview with blanks if needed\n            while (rowAccumulator.length < PREVIEW_ROW_COUNT) {\n                rowAccumulator.push([]);\n            }\n            resolve({\n                file,\n                parseError: undefined,\n                parseWarning: firstWarning || undefined,\n                firstChunk: firstChunk || '',\n                firstRows: rowAccumulator,\n                isSingleLine\n            });\n        }\n        // true streaming support for local files (@todo wait for upstream fix)\n        // @todo close the stream\n        const nodeStream = new ReadableWebToNodeStream(file.stream());\n        Papa.parse(nodeStream, Object.assign(Object.assign({}, customConfig), { chunkSize: 10000, preview: PREVIEW_ROW_COUNT, skipEmptyLines: true, error: (error) => {\n                resolve({\n                    parseError: error\n                });\n            }, beforeFirstChunk: (chunk) => {\n                firstChunk = chunk;\n            }, chunk: ({ data, errors }, parser) => {\n                // ignoring possible leading BOM\n                data.forEach((row) => {\n                    rowAccumulator.push(row.map((item) => typeof item === 'string' ? item : ''));\n                });\n                if (errors.length > 0 && !firstWarning) {\n                    firstWarning = errors[0];\n                }\n                // finish parsing after first chunk\n                nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n                parser.abort();\n                reportSuccess();\n            }, complete: reportSuccess }));\n    }).catch((error) => {\n        return {\n            parseError: error // delegate message display to UI logic\n        };\n    });\n}\nexport function processFile(file, hasHeaders, fieldAssignments, reportProgress, callback, chunkSize) {\n    const fieldNames = Object.keys(fieldAssignments);\n    // wrap synchronous errors in promise\n    return new Promise((resolve, reject) => {\n        // skip first line if needed\n        let skipLine = hasHeaders;\n        let skipBOM = !hasHeaders;\n        let processedCount = 0;\n        // true streaming support for local files (@todo wait for upstream fix)\n        const nodeStream = new ReadableWebToNodeStream(file.stream());\n        Papa.parse(nodeStream, {\n            chunkSize: chunkSize || 10000,\n            skipEmptyLines: true,\n            error: (error) => {\n                reject(error);\n            },\n            chunk: ({ data }, parser) => {\n                // pause to wait until the rows are consumed\n                nodeStream.pause(); // parser does not pause source stream, do it here explicitly\n                parser.pause();\n                const skipped = skipLine && data.length > 0;\n                const rows = (skipped ? data.slice(1) : data).map((row) => {\n                    const stringRow = row.map((item) => typeof item === 'string' ? item : '');\n                    // perform BOM skip on first value\n                    if (skipBOM && stringRow.length > 0) {\n                        skipBOM = false;\n                        stringRow[0] =\n                            stringRow[0].charCodeAt(0) === BOM_CODE\n                                ? stringRow[0].substring(1)\n                                : stringRow[0];\n                    }\n                    const record = {};\n                    fieldNames.forEach((fieldName) => {\n                        const columnIndex = fieldAssignments[fieldName];\n                        if (columnIndex !== undefined) {\n                            record[fieldName] = stringRow[columnIndex];\n                        }\n                    });\n                    return record; // @todo look into a more precise setup\n                });\n                // clear line skip flag if there was anything to skip\n                if (skipped) {\n                    skipLine = false;\n                }\n                // info snapshot for processing callback\n                const info = {\n                    startIndex: processedCount\n                };\n                processedCount += rows.length;\n                // @todo collect errors\n                reportProgress(rows.length);\n                // wrap sync errors in promise\n                // (avoid invoking callback if there are no rows to consume)\n                const whenConsumed = new Promise((resolve) => {\n                    const result = rows.length ? callback(rows, info) : undefined;\n                    // introduce delay to allow a frame render\n                    setTimeout(() => resolve(result), 0);\n                });\n                // unpause parsing when done\n                whenConsumed.then(() => {\n                    nodeStream.resume();\n                    parser.resume();\n                }, () => {\n                    // @todo collect errors\n                    nodeStream.resume();\n                    parser.resume();\n                });\n            },\n            complete: () => {\n                resolve();\n            }\n        });\n    });\n}\n","import React from 'react';\nimport './TextButton.scss';\nexport const TextButton = ({ disabled, onClick, children }) => {\n    return (React.createElement(\"button\", { className: \"CSVImporter_TextButton\", disabled: disabled, onClick: onClick }, children));\n};\n","import React from 'react';\nimport './IconButton.scss';\nexport const IconButton = ({ type, label, small, focusOnly, disabled, onClick }) => {\n    return (React.createElement(\"button\", { className: \"CSVImporter_IconButton\", \"aria-label\": label, disabled: disabled, onClick: onClick, \"data-small\": !!small, \"data-focus-only\": !!focusOnly },\n        React.createElement(\"span\", { \"data-type\": type })));\n};\n","import React, { useRef, useEffect } from 'react';\nimport { TextButton } from './TextButton';\nimport { IconButton } from './IconButton';\nimport './ImporterFrame.scss';\nexport const ImporterFrame = ({ fileName, subtitle, secondaryDisabled, secondaryLabel, nextDisabled, nextLabel, error, onSecondary, onNext, onCancel, children }) => {\n    const titleRef = useRef(null);\n    const subtitleRef = useRef(null);\n    useEffect(() => {\n        if (subtitleRef.current) {\n            subtitleRef.current.focus();\n        }\n        else if (titleRef.current) {\n            titleRef.current.focus();\n        }\n    }, []);\n    return (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame\" },\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__header\" },\n            React.createElement(IconButton, { label: \"Go to previous step\", type: \"arrowBack\", disabled: !onCancel, onClick: onCancel }),\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerTitle\", tabIndex: -1, ref: titleRef }, fileName),\n            subtitle ? (React.createElement(React.Fragment, null,\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerCrumbSeparator\" },\n                    React.createElement(\"span\", null)),\n                React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__headerSubtitle\", tabIndex: -1, ref: subtitleRef }, subtitle))) : null),\n        children,\n        React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footer\" },\n            React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerFill\" }),\n            error ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerError\", role: \"status\" }, error)) : null,\n            secondaryLabel ? (React.createElement(\"div\", { className: \"CSVImporter_ImporterFrame__footerSecondary\" },\n                React.createElement(TextButton, { disabled: !!secondaryDisabled, onClick: onSecondary }, secondaryLabel))) : null,\n            React.createElement(TextButton, { disabled: !!nextDisabled, onClick: onNext }, nextLabel || 'Next'))));\n};\n","import React from 'react';\nimport { TextButton } from './TextButton';\nimport './FormatErrorMessage.scss';\nexport const FormatErrorMessage = React.memo(({ onCancelClick, children }) => {\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatErrorMessage\" },\n        React.createElement(\"span\", null, children),\n        React.createElement(TextButton, { onClick: onCancelClick }, \"Go Back\")));\n});\n","import React from 'react';\nimport { FormatErrorMessage } from './FormatErrorMessage';\nimport './FormatRawPreview.scss';\nconst RAW_PREVIEW_SIZE = 500;\nexport const FormatRawPreview = React.memo(({ chunk, warning, onCancelClick }) => {\n    const chunkSlice = chunk.slice(0, RAW_PREVIEW_SIZE);\n    const chunkHasMore = chunk.length > RAW_PREVIEW_SIZE;\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview\" },\n        React.createElement(\"div\", { className: \"CSVImporter_FormatRawPreview__scroll\" },\n            React.createElement(\"pre\", { className: \"CSVImporter_FormatRawPreview__pre\" },\n                chunkSlice,\n                chunkHasMore && React.createElement(\"aside\", null, \"...\"))),\n        warning ? (React.createElement(FormatErrorMessage, { onCancelClick: onCancelClick },\n            warning.message || String(warning),\n            \": please check data formatting\")) : null));\n});\n","import React from 'react';\nimport './FormatDataRowPreview.scss';\nexport const FormatDataRowPreview = React.memo(({ hasHeaders, rows }) => {\n    const headerRow = hasHeaders ? rows[0] : null;\n    const bodyRows = hasHeaders ? rows.slice(1) : rows;\n    return (React.createElement(\"div\", { className: \"CSVImporter_FormatDataRowPreview\" },\n        React.createElement(\"table\", { className: \"CSVImporter_FormatDataRowPreview__table\" },\n            headerRow && (React.createElement(\"thead\", null,\n                React.createElement(\"tr\", null, headerRow.map((item, itemIndex) => (React.createElement(\"th\", { key: itemIndex }, item)))))),\n            React.createElement(\"tbody\", null, bodyRows.map((row, rowIndex) => (React.createElement(\"tr\", { key: rowIndex }, row.map((item, itemIndex) => (React.createElement(\"td\", { key: itemIndex }, item))))))))));\n});\n","import React, { useMemo, useRef, useEffect, useState } from 'react';\nimport { parsePreview } from './parser';\nimport { ImporterFrame } from './ImporterFrame';\nimport { FormatRawPreview } from './FormatRawPreview';\nimport { FormatDataRowPreview } from './FormatDataRowPreview';\nimport { FormatErrorMessage } from './FormatErrorMessage';\nimport './FormatPreview.scss';\nexport const FormatPreview = ({ customConfig, file, assumeNoHeaders, currentPreview, onChange, onAccept, onCancel }) => {\n    // augmented PreviewResults from parser\n    const [preview, setPreview] = useState(() => currentPreview && Object.assign({ parseError: undefined }, currentPreview));\n    // wrap in ref to avoid triggering effect\n    const customConfigRef = useRef(customConfig);\n    customConfigRef.current = customConfig;\n    const assumeNoHeadersRef = useRef(assumeNoHeaders);\n    assumeNoHeadersRef.current = assumeNoHeaders;\n    const onChangeRef = useRef(onChange);\n    onChangeRef.current = onChange;\n    // notify of current state\n    useEffect(() => {\n        onChangeRef.current(preview && !preview.parseError ? preview : null);\n    }, [preview]);\n    // perform async preview parse\n    const asyncLockRef = useRef(0);\n    useEffect(() => {\n        // avoid re-parsing if already set up a preview for this file\n        if (preview && !preview.parseError && preview.file === file) {\n            return;\n        }\n        const oplock = asyncLockRef.current;\n        parsePreview(file, customConfigRef.current).then((results) => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return;\n            }\n            if (results.parseError) {\n                setPreview(results);\n            }\n            else {\n                // pre-fill headers flag (only possible with >1 lines)\n                const hasHeaders = !assumeNoHeadersRef.current && !results.isSingleLine;\n                setPreview(Object.assign(Object.assign({}, results), { hasHeaders }));\n            }\n        });\n        return () => {\n            // invalidate current oplock on change or unmount\n            asyncLockRef.current += 1;\n        };\n    }, [file, preview]);\n    const report = useMemo(() => {\n        if (!preview) {\n            return null;\n        }\n        if (preview.parseError) {\n            return (React.createElement(\"div\", { className: \"CSVImporter_FormatPreview__mainResultBlock\" },\n                React.createElement(FormatErrorMessage, { onCancelClick: onCancel },\n                    \"Import error:\",\n                    ' ',\n                    React.createElement(\"b\", null, preview.parseError.message || String(preview.parseError)))));\n        }\n        return (React.createElement(\"div\", { className: \"CSVImporter_FormatPreview__mainResultBlock\" },\n            React.createElement(\"div\", { className: \"CSVImporter_FormatPreview__header\" }, \"Raw File Contents\"),\n            React.createElement(FormatRawPreview, { chunk: preview.firstChunk, warning: preview.parseWarning, onCancelClick: onCancel }),\n            preview.parseWarning ? null : (React.createElement(React.Fragment, null,\n                React.createElement(\"div\", { className: \"CSVImporter_FormatPreview__header\" },\n                    \"Preview Import\",\n                    !preview.isSingleLine && ( // hide setting if only one line anyway\n                    React.createElement(\"label\", { className: \"CSVImporter_FormatPreview__headerToggle\" },\n                        React.createElement(\"input\", { type: \"checkbox\", checked: preview.hasHeaders, onChange: () => {\n                                setPreview((prev) => prev && !prev.parseError // appease type safety\n                                    ? Object.assign(Object.assign({}, prev), { hasHeaders: !prev.hasHeaders }) : prev);\n                            } }),\n                        React.createElement(\"span\", null, \"Data has headers\")))),\n                React.createElement(FormatDataRowPreview, { hasHeaders: preview.hasHeaders, rows: preview.firstRows })))));\n    }, [preview, onCancel]);\n    return (React.createElement(ImporterFrame, { fileName: file.name, nextDisabled: !preview || !!preview.parseError || !!preview.parseWarning, onNext: () => {\n            if (!preview || preview.parseError) {\n                throw new Error('unexpected missing preview info');\n            }\n            onAccept();\n        }, onCancel: onCancel }, report || (React.createElement(\"div\", { className: \"CSVImporter_FormatPreview__mainPendingBlock\" }, \"Loading preview...\"))));\n};\n","import { useState, useCallback, useEffect, useRef } from 'react';\nimport { useDrag } from 'react-use-gesture';\nexport function useColumnDragState(fields, initialAssignments, onTouched) {\n    // wrap in ref to avoid re-triggering\n    const onTouchedRef = useRef(onTouched);\n    onTouchedRef.current = onTouched;\n    const [dragState, setDragState] = useState(null);\n    const [fieldAssignments, setFieldAssignments] = useState(initialAssignments);\n    // make sure there are no extra fields\n    useEffect(() => {\n        const removedFieldNames = Object.keys(fieldAssignments).filter((existingFieldName) => !fields.some((field) => field.name === existingFieldName));\n        if (removedFieldNames.length > 0) {\n            // @todo put everything inside this setter\n            setFieldAssignments((prev) => {\n                const copy = Object.assign({}, prev);\n                removedFieldNames.forEach((fieldName) => {\n                    delete copy[fieldName];\n                });\n                return copy;\n            });\n        }\n    }, [fields, fieldAssignments]);\n    const internalAssignHandler = useCallback((column, fieldName) => {\n        setFieldAssignments((prevAssignments) => {\n            const copy = Object.assign({}, prevAssignments);\n            // ensure dropped column does not show up elsewhere\n            Object.keys(prevAssignments).forEach((name) => {\n                if (copy[name] === column.index) {\n                    delete copy[name];\n                }\n            });\n            // set new field column\n            if (fieldName !== null) {\n                copy[fieldName] = column.index;\n            }\n            return copy;\n        });\n        // mark for validation display\n        if (fieldName) {\n            onTouchedRef.current(fieldName);\n        }\n    }, []);\n    const bindDrag = useDrag(({ first, last, event, xy, args }) => {\n        if (first && event) {\n            event.preventDefault();\n            const [column, startFieldName] = args;\n            setDragState({\n                pointerStartInfo: {\n                    initialXY: xy,\n                    initialWidth: event.currentTarget instanceof HTMLElement\n                        ? event.currentTarget.offsetWidth\n                        : 0\n                },\n                column,\n                dropFieldName: startFieldName !== undefined ? startFieldName : null,\n                updateListener: null\n            });\n        }\n        else if (last) {\n            setDragState(null);\n            if (dragState) {\n                internalAssignHandler(dragState.column, dragState.dropFieldName);\n            }\n        }\n        // @todo figure out a cleaner event stream solution\n        if (dragState && dragState.updateListener) {\n            dragState.updateListener(xy);\n        }\n    }, {});\n    const columnSelectHandler = useCallback((column) => {\n        setDragState((prev) => {\n            // toggle off if needed\n            if (prev && prev.column === column) {\n                return null;\n            }\n            return {\n                pointerStartInfo: null,\n                column,\n                dropFieldName: null,\n                updateListener: null\n            };\n        });\n    }, []);\n    const dragHoverHandler = useCallback((fieldName, isOn) => {\n        setDragState((prev) => {\n            if (!prev) {\n                return prev;\n            }\n            if (isOn) {\n                // set the new drop target\n                return Object.assign(Object.assign({}, prev), { dropFieldName: fieldName });\n            }\n            else if (prev.dropFieldName === fieldName) {\n                // clear drop target if we are still the current one\n                return Object.assign(Object.assign({}, prev), { dropFieldName: null });\n            }\n            // no changes by default\n            return prev;\n        });\n    }, []);\n    const assignHandler = useCallback((fieldName) => {\n        // clear active drag state\n        setDragState(null);\n        if (dragState) {\n            internalAssignHandler(dragState.column, fieldName);\n        }\n    }, [internalAssignHandler, dragState]);\n    const unassignHandler = useCallback((column) => {\n        setFieldAssignments((prev) => {\n            const assignedFieldName = Object.keys(prev).find((fieldName) => prev[fieldName] === column.index);\n            if (assignedFieldName === undefined) {\n                return prev;\n            }\n            const copy = Object.assign({}, prev);\n            delete copy[assignedFieldName];\n            return copy;\n        });\n    }, []);\n    return {\n        fieldAssignments,\n        dragState,\n        dragEventBinder: bindDrag,\n        dragHoverHandler,\n        columnSelectHandler,\n        assignHandler,\n        unassignHandler\n    };\n}\n","import React, { useMemo } from 'react';\nimport { PREVIEW_ROW_COUNT } from './parser';\nimport './ColumnDragCard.scss';\n// @todo sort out \"grabbing\" cursor state (does not work with pointer-events:none)\nexport const ColumnDragCard = ({ column: optionalColumn, rowCount = PREVIEW_ROW_COUNT, hasError, isAssigned, isShadow, isDraggable, isDragged, isDropIndicator }) => {\n    const isDummy = !optionalColumn;\n    const column = useMemo(() => optionalColumn || {\n        index: -1,\n        code: '',\n        values: [...new Array(PREVIEW_ROW_COUNT)].map(() => '')\n    }, [optionalColumn]);\n    const headerValue = column.header;\n    const dataValues = column.values.slice(0, headerValue === undefined ? rowCount : rowCount - 1);\n    return (\n    // not changing variant dynamically because it causes a height jump\n    React.createElement(\"div\", { key: isDummy || isShadow ? 1 : isDropIndicator ? 2 : 0, className: \"CSVImporter_ColumnDragCard\", \"data-dummy\": !!isDummy, \"data-error\": !!hasError, \"data-shadow\": !!isShadow, \"data-draggable\": !!isDraggable, \"data-dragged\": !!isDragged, \"data-drop-indicator\": !!isDropIndicator },\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardHeader\" },\n            isDummy ? (React.createElement(\"var\", { role: \"text\" }, \"Unassigned field\")) : (React.createElement(\"var\", { role: \"text\" },\n                \"Column \",\n                column.code)),\n            isDummy || isAssigned ? '\\u00a0' : React.createElement(\"b\", { \"aria-hidden\": true }, column.code)),\n        headerValue !== undefined ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragCard__cardValue\", \"data-header\": true }, headerValue || '\\u00a0')) : null,\n        React.createElement(\"div\", { role: \"text\" }, dataValues.map((value, valueIndex) => (React.createElement(\"div\", { key: valueIndex, className: \"CSVImporter_ColumnDragCard__cardValue\" }, value || '\\u00a0'))))));\n};\n","import React, { useRef, useLayoutEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { ColumnDragCard } from './ColumnDragCard';\nimport './ColumnDragObject.scss';\nexport const ColumnDragObject = ({ dragState }) => {\n    const referenceBoxRef = useRef(null);\n    // @todo wrap in a no-events overlay to clip against screen edges\n    const dragBoxRef = useRef(null);\n    const dragObjectPortal = dragState && dragState.pointerStartInfo\n        ? createPortal(React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject\", ref: dragBoxRef },\n            React.createElement(\"div\", { className: \"CSVImporter_ColumnDragObject__holder\" },\n                React.createElement(ColumnDragCard, { column: dragState.column, isDragged: true }))), document.body)\n        : null;\n    // set up initial position\n    const pointerStartInfo = dragState && dragState.pointerStartInfo;\n    useLayoutEffect(() => {\n        if (!pointerStartInfo || !dragBoxRef.current) {\n            return;\n        }\n        const { initialXY, initialWidth } = pointerStartInfo;\n        dragBoxRef.current.style.left = `${initialXY[0]}px`;\n        dragBoxRef.current.style.top = `${initialXY[1]}px`;\n        dragBoxRef.current.style.width = `${initialWidth}px`;\n        // copy known font style from main content\n        // @todo consider other text style properties?\n        if (referenceBoxRef.current) {\n            const computedStyle = window.getComputedStyle(referenceBoxRef.current);\n            dragBoxRef.current.style.fontFamily = computedStyle.fontFamily;\n            dragBoxRef.current.style.fontSize = computedStyle.fontSize;\n            dragBoxRef.current.style.fontWeight = computedStyle.fontWeight;\n            dragBoxRef.current.style.fontStyle = computedStyle.fontStyle;\n            dragBoxRef.current.style.letterSpacing = computedStyle.letterSpacing;\n        }\n    }, [pointerStartInfo]);\n    // subscribe to live position updates without state changes\n    useLayoutEffect(() => {\n        if (dragState) {\n            dragState.updateListener = (xy) => {\n                if (!dragBoxRef.current) {\n                    return;\n                }\n                dragBoxRef.current.style.left = `${xy[0]}px`;\n                dragBoxRef.current.style.top = `${xy[1]}px`;\n            };\n        }\n    }, [dragState]);\n    return React.createElement(\"div\", { ref: referenceBoxRef }, dragObjectPortal);\n};\n","import React, { useState, useMemo } from 'react';\nimport { ColumnDragCard } from './ColumnDragCard';\nimport { IconButton } from './IconButton';\nimport './ColumnDragSourceArea.scss';\nconst SOURCES_PAGE_SIZE = 5; // fraction of 10 for easier counting\n// @todo readable status text if not mouse-drag\nconst SourceBox = ({ column, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\n    const isDragged = dragState ? column === dragState.column : false;\n    const isAssigned = useMemo(() => Object.keys(fieldAssignments).some((fieldName) => fieldAssignments[fieldName] === column.index), [fieldAssignments, column]);\n    const eventHandlers = useMemo(() => eventBinder(column), [\n        eventBinder,\n        column\n    ]);\n    return (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__box\" },\n        React.createElement(\"div\", Object.assign({}, (isAssigned ? {} : eventHandlers)),\n            React.createElement(ColumnDragCard, { column: column, isAssigned: isAssigned, isShadow: isDragged || isAssigned, isDraggable: !dragState && !isDragged && !isAssigned })),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__boxAction\" }, isAssigned ? (React.createElement(IconButton, { key: \"clear\" // key-prop helps clear focus on click\n            , label: \"Clear column assignment\", small: true, type: \"replay\", onClick: () => {\n                onUnassign(column);\n            } })) : (React.createElement(IconButton, { key: \"dragSelect\" // key-prop helps clear focus on click\n            , focusOnly: true, label: dragState && dragState.column === column\n                ? 'Unselect column'\n                : 'Select column for assignment', small: true, type: \"back\", onClick: () => {\n                onSelect(column);\n            } })))));\n};\n// @todo current page indicator (dots)\nexport const ColumnDragSourceArea = ({ columns, fieldAssignments, dragState, eventBinder, onSelect, onUnassign }) => {\n    const [page, setPage] = useState(0);\n    const [pageChanged, setPageChanged] = useState(false);\n    const pageCount = Math.ceil(columns.length / SOURCES_PAGE_SIZE);\n    const start = page * SOURCES_PAGE_SIZE;\n    const pageContents = columns\n        .slice(start, start + SOURCES_PAGE_SIZE)\n        .map((column, columnIndex) => (React.createElement(SourceBox, { key: columnIndex, column: column, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: eventBinder, onSelect: onSelect, onUnassign: onUnassign })));\n    while (pageContents.length < SOURCES_PAGE_SIZE) {\n        pageContents.push(React.createElement(\"div\", { key: pageContents.length, className: \"CSVImporter_ColumnDragSourceArea__pageFiller\" }));\n    }\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragSourceArea\", \"aria-label\": \"Columns to import\" },\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\n            React.createElement(IconButton, { label: \"Show previous columns\", type: \"back\", disabled: page === 0, onClick: () => {\n                    setPage((prev) => Math.max(0, prev - 1));\n                    setPageChanged(true);\n                } })),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__page\" },\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: \"status\" },\n                \"Assigning column \",\n                dragState.column.code)) : (\n            // show page number if needed (and treat as status role if it has changed)\n            // @todo changing role to status does not seem to work\n            pageCount > 1 && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__pageIndicator\", role: pageChanged ? 'status' : 'text' },\n                \"Page \",\n                page + 1,\n                \" of \",\n                pageCount))),\n            pageContents),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragSourceArea__control\" },\n            React.createElement(IconButton, { label: \"Show next columns\", type: \"forward\", disabled: page === pageCount - 1, onClick: () => {\n                    setPage((prev) => Math.min(pageCount - 1, prev + 1));\n                } }))));\n};\n","import React, { useMemo } from 'react';\nimport { ColumnDragCard } from './ColumnDragCard';\nimport { IconButton } from './IconButton';\nimport './ColumnDragTargetArea.scss';\nconst TargetBox = ({ field, touched, assignedColumn, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\n    const mouseHoverHandlers = dragState && dragState.pointerStartInfo\n        ? {\n            onMouseEnter: () => onHover(field.name, true),\n            onMouseLeave: () => onHover(field.name, false)\n        }\n        : {};\n    const sourceColumn = dragState && dragState.dropFieldName === field.name\n        ? dragState.column\n        : null;\n    // see if currently assigned column is being dragged again\n    const isReDragged = dragState ? dragState.column === assignedColumn : false;\n    const dragHandlers = useMemo(() => assignedColumn && !isReDragged\n        ? eventBinder(assignedColumn, field.name)\n        : {}, [eventBinder, assignedColumn, isReDragged, field.name]);\n    const valueContents = useMemo(() => {\n        if (sourceColumn) {\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: sourceColumn, isDropIndicator: true }));\n        }\n        if (assignedColumn) {\n            return (React.createElement(ColumnDragCard, { rowCount: 3, column: assignedColumn, isShadow: isReDragged, isDraggable: !isReDragged }));\n        }\n        const hasError = touched && !field.isOptional;\n        return React.createElement(ColumnDragCard, { rowCount: 3, hasError: hasError });\n    }, [field, touched, assignedColumn, sourceColumn, isReDragged]);\n    // @todo mouse cursor changes to reflect draggable state\n    return (React.createElement(\"section\", Object.assign({ className: \"CSVImporter_ColumnDragTargetArea__box\", \"aria-label\": `${field.label} (${field.isOptional ? 'optional' : 'required'})` }, mouseHoverHandlers),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxLabel\", \"aria-hidden\": true },\n            field.label,\n            field.isOptional ? null : React.createElement(\"b\", null, \"*\")),\n        React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValue\" },\n            !sourceColumn && !assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxPlaceholderHelp\", \"aria-hidden\": true }, \"Drag column here\")),\n            React.createElement(\"div\", Object.assign({}, dragHandlers), valueContents),\n            dragState && !dragState.pointerStartInfo ? (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\n                React.createElement(IconButton, { label: `Assign column ${dragState.column.code}`, small: true, type: \"forward\", onClick: () => onAssign(field.name) }))) : (!sourceColumn &&\n                assignedColumn && (React.createElement(\"div\", { className: \"CSVImporter_ColumnDragTargetArea__boxValueAction\" },\n                React.createElement(IconButton, { label: \"Clear column assignment\", small: true, type: \"close\", onClick: () => onUnassign(assignedColumn) })))))));\n};\nexport const ColumnDragTargetArea = ({ fields, columns, fieldTouched, fieldAssignments, dragState, eventBinder, onHover, onAssign, onUnassign }) => {\n    return (React.createElement(\"section\", { className: \"CSVImporter_ColumnDragTargetArea\", \"aria-label\": \"Target fields\" }, fields.map((field) => {\n        const assignedColumnIndex = fieldAssignments[field.name];\n        return (React.createElement(TargetBox, { key: field.name, field: field, touched: fieldTouched[field.name], assignedColumn: assignedColumnIndex !== undefined\n                ? columns[assignedColumnIndex]\n                : null, dragState: dragState, eventBinder: eventBinder, onHover: onHover, onAssign: onAssign, onUnassign: onUnassign }));\n    })));\n};\n","import React, { useState, useMemo } from 'react';\nimport { ImporterFrame } from './ImporterFrame';\nimport { generatePreviewColumns, generateColumnCode } from './ColumnPreview';\nimport { useColumnDragState } from './ColumnDragState';\nimport { ColumnDragObject } from './ColumnDragObject';\nimport { ColumnDragSourceArea } from './ColumnDragSourceArea';\nimport { ColumnDragTargetArea } from './ColumnDragTargetArea';\nexport const ColumnPicker = ({ fields, preview, onAccept, onCancel }) => {\n    const columns = useMemo(() => generatePreviewColumns(preview.firstRows, preview.hasHeaders).map((item) => (Object.assign(Object.assign({}, item), { code: generateColumnCode(item.index) }))), [preview]);\n    const initialAssignments = useMemo(() => {\n        // prep insensitive/fuzzy match stems for known columns\n        const columnStems = columns.map((column) => {\n            const trimmed = column.header && column.header.trim();\n            if (!trimmed) {\n                return undefined;\n            }\n            return trimmed.toLowerCase();\n        });\n        // pre-assign corresponding fields\n        const result = {};\n        const assignedColumnIndexes = [];\n        fields.forEach((field) => {\n            // find by field stem\n            const fieldLabelStem = field.label.trim().toLowerCase(); // @todo consider normalizing other whitespace/non-letters\n            const matchingColumnIndex = columnStems.findIndex((columnStem, columnIndex) => {\n                // no headers or no meaningful stem value\n                if (columnStem === undefined) {\n                    return false;\n                }\n                // always check against assigning twice\n                if (assignedColumnIndexes[columnIndex]) {\n                    return false;\n                }\n                return columnStem === fieldLabelStem;\n            });\n            // assign if found\n            if (matchingColumnIndex !== -1) {\n                assignedColumnIndexes[matchingColumnIndex] = true;\n                result[field.name] = matchingColumnIndex;\n            }\n        });\n        return result;\n    }, [fields, columns]);\n    // track which fields need to show validation warning\n    const [fieldTouched, setFieldTouched] = useState({});\n    const [validationError, setValidationError] = useState(null);\n    const { fieldAssignments, dragState, dragEventBinder, dragHoverHandler, columnSelectHandler, assignHandler, unassignHandler } = useColumnDragState(fields, initialAssignments, (fieldName) => {\n        setFieldTouched((prev) => {\n            if (prev[fieldName]) {\n                return prev;\n            }\n            const copy = Object.assign({}, prev);\n            copy[fieldName] = true;\n            return copy;\n        });\n    });\n    return (React.createElement(ImporterFrame, { fileName: preview.file.name, subtitle: \"Select Columns\", error: validationError, onCancel: onCancel, onNext: () => {\n            // mark all fields as touched\n            const fullTouchedMap = {};\n            fields.some((field) => {\n                fullTouchedMap[field.name] = true;\n            });\n            setFieldTouched(fullTouchedMap);\n            // submit if validation succeeds\n            const hasUnassignedRequired = fields.some((field) => !field.isOptional && fieldAssignments[field.name] === undefined);\n            if (!hasUnassignedRequired) {\n                onAccept(Object.assign({}, fieldAssignments));\n            }\n            else {\n                setValidationError('Please assign all required fields');\n            }\n        } },\n        React.createElement(ColumnDragSourceArea, { columns: columns, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onSelect: columnSelectHandler, onUnassign: unassignHandler }),\n        React.createElement(ColumnDragTargetArea, { fields: fields, columns: columns, fieldTouched: fieldTouched, fieldAssignments: fieldAssignments, dragState: dragState, eventBinder: dragEventBinder, onHover: dragHoverHandler, onAssign: assignHandler, onUnassign: unassignHandler }),\n        React.createElement(ColumnDragObject, { dragState: dragState })));\n};\n","import React, { useState, useEffect, useMemo, useRef } from 'react';\nimport { processFile } from './parser';\nimport { ImporterFrame } from './ImporterFrame';\nimport './ProgressDisplay.scss';\n// compute actual UTF-8 bytes used by a string\n// (inspired by https://stackoverflow.com/questions/10576905/how-to-convert-javascript-unicode-notation-code-to-utf-8)\nfunction countUTF8Bytes(item) {\n    // re-encode into UTF-8\n    const escaped = encodeURIComponent(item);\n    // convert byte escape sequences into single characters\n    const normalized = escaped.replace(/%\\d\\d/g, '_');\n    return normalized.length;\n}\nexport function ProgressDisplay({ preview, externalPreview, chunkSize, fieldAssignments, processChunk, onStart, onComplete, onRestart, onClose }) {\n    const [progressCount, setProgressCount] = useState(0);\n    const [isComplete, setIsComplete] = useState(false);\n    const [error, setError] = useState(null);\n    const [isDismissed, setIsDismissed] = useState(false); // prevents double-clicking finish\n    const importInfo = useMemo(() => {\n        const fieldList = Object.keys(fieldAssignments);\n        const columnSparseList = [];\n        fieldList.forEach((field) => {\n            const col = fieldAssignments[field];\n            if (col !== undefined) {\n                columnSparseList[col] = field;\n            }\n        });\n        return {\n            file: preview.file,\n            preview: externalPreview,\n            fields: fieldList,\n            columnFields: [...columnSparseList]\n        };\n    }, [preview, externalPreview, fieldAssignments]);\n    // estimate number of rows\n    const estimatedRowCount = useMemo(() => {\n        // sum up sizes of all the parsed preview rows and get estimated average\n        const totalPreviewRowBytes = preview.firstRows.reduce((prevCount, row) => {\n            const rowBytes = row.reduce((prev, item) => {\n                return prev + countUTF8Bytes(item) + 1; // add a byte for separator or newline\n            }, 0);\n            return prevCount + rowBytes;\n        }, 0);\n        const averagePreviewRowSize = totalPreviewRowBytes / preview.firstRows.length;\n        // divide file size by estimated row size (or fall back to a sensible amount)\n        return averagePreviewRowSize > 1\n            ? preview.file.size / averagePreviewRowSize\n            : 100;\n    }, [preview]);\n    // notify on start of processing\n    // (separate effect in case of errors)\n    const onStartRef = useRef(onStart); // wrap in ref to avoid re-triggering (only first instance is needed)\n    useEffect(() => {\n        if (onStartRef.current) {\n            onStartRef.current(importInfo);\n        }\n    }, [importInfo]);\n    // notify on end of processing\n    // (separate effect in case of errors)\n    const onCompleteRef = useRef(onComplete); // wrap in ref to avoid re-triggering\n    onCompleteRef.current = onComplete;\n    useEffect(() => {\n        if (isComplete && onCompleteRef.current) {\n            onCompleteRef.current(importInfo);\n        }\n    }, [importInfo, isComplete]);\n    // ensure status gets focus when complete, in case status role is not read out\n    const statusRef = useRef(null);\n    useEffect(() => {\n        if ((isComplete || error) && statusRef.current) {\n            statusRef.current.focus();\n        }\n    }, [isComplete, error]);\n    // perform main async parse\n    const chunkSizeRef = useRef(chunkSize); // wrap in ref to avoid re-triggering\n    const processChunkRef = useRef(processChunk); // wrap in ref to avoid re-triggering\n    const asyncLockRef = useRef(0);\n    useEffect(() => {\n        const oplock = asyncLockRef.current;\n        processFile(preview.file, preview.hasHeaders, fieldAssignments, (deltaCount) => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return; // @todo signal abort\n            }\n            setProgressCount((prev) => prev + deltaCount);\n        }, processChunkRef.current, chunkSizeRef.current).then(() => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return;\n            }\n            setIsComplete(true);\n        }, (error) => {\n            // ignore if stale\n            if (oplock !== asyncLockRef.current) {\n                return;\n            }\n            setError(error);\n        });\n        return () => {\n            // invalidate current oplock on change or unmount\n            asyncLockRef.current += 1;\n        };\n    }, [preview, fieldAssignments]);\n    // simulate asymptotic progress percentage\n    const progressPercentage = useMemo(() => {\n        if (isComplete) {\n            return 100;\n        }\n        // inputs hand-picked so that correctly estimated total is about 75% of the bar\n        const progressPower = 2.5 * (progressCount / estimatedRowCount);\n        const progressLeft = Math.pow(0.5, progressPower);\n        // convert to .1 percent precision for smoother bar display\n        return Math.floor(1000 - 1000 * progressLeft) / 10;\n    }, [estimatedRowCount, progressCount, isComplete]);\n    return (React.createElement(ImporterFrame, { fileName: preview.file.name, subtitle: \"Import\", error: error && (error.message || String(error)), secondaryDisabled: !isComplete || isDismissed, secondaryLabel: onRestart && onClose ? 'Upload More' : undefined, onSecondary: onRestart && onClose ? onRestart : undefined, nextDisabled: (!onClose && !onRestart) || !isComplete || isDismissed, nextLabel: !onClose && onRestart ? 'Upload More' : 'Finish', onNext: () => {\n            setIsDismissed(true);\n            if (onClose) {\n                onClose(importInfo);\n            }\n            else if (onRestart) {\n                onRestart();\n            }\n        } },\n        React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay\" },\n            isComplete || error ? (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status\", role: \"status\", tabIndex: -1, ref: statusRef }, error ? 'Could not import' : 'Complete')) : (React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__status -pending\", role: \"status\" }, \"Importing...\")),\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__count\", role: \"text\" },\n                React.createElement(\"var\", null, \"Processed rows:\"),\n                \" \",\n                progressCount),\n            React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBar\" },\n                React.createElement(\"div\", { className: \"CSVImporter_ProgressDisplay__progressBarIndicator\", style: { width: `${progressPercentage}%` } })))));\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { useMemo, useState, useCallback, useEffect, useContext } from 'react';\nimport { generatePreviewColumns } from './ColumnPreview';\nimport { FileSelector } from './FileSelector';\nimport { FormatPreview } from './FormatPreview';\nimport { ColumnPicker } from './ColumnPicker';\nimport { ProgressDisplay } from './ProgressDisplay';\nimport './Importer.scss';\nconst FieldDefinitionContext = React.createContext(null);\nlet fieldIdCount = 0;\n// defines a field to be filled from file column during import\nexport const ImporterField = ({ name, label, optional }) => {\n    const fieldId = useMemo(() => (fieldIdCount += 1), []);\n    const fieldSetter = useContext(FieldDefinitionContext);\n    // update central list as needed\n    useEffect(() => {\n        if (!fieldSetter) {\n            console.error('importer field must be a child of importer'); // @todo\n            return;\n        }\n        fieldSetter((prev) => {\n            const newField = { id: fieldId, name, label, isOptional: !!optional };\n            const copy = [...prev];\n            const existingIndex = copy.findIndex((item) => item.name === name);\n            // preserve existing array position if possible\n            // @todo keep both copies in a map to deal with dynamic fields better\n            if (existingIndex === -1) {\n                copy.push(newField);\n            }\n            else {\n                copy[existingIndex] = newField;\n            }\n            return copy;\n        });\n    }, [fieldId, fieldSetter, name, label, optional]);\n    // on component unmount, remove this field from list by ID\n    useEffect(() => {\n        if (!fieldSetter) {\n            console.error('importer field must be a child of importer'); // @todo\n            return;\n        }\n        return () => {\n            fieldSetter((prev) => {\n                return prev.filter((field) => field.id !== fieldId);\n            });\n        };\n    }, [fieldId, fieldSetter]);\n    return null;\n};\nconst ContentWrapper = ({ setFields, preview, externalPreview, content, children }) => {\n    const finalContent = useMemo(() => {\n        return typeof content === 'function'\n            ? content({\n                file: preview && preview.file,\n                preview: externalPreview\n            })\n            : content;\n    }, [preview, externalPreview, content]);\n    return (React.createElement(\"div\", { className: \"CSVImporter_Importer\" },\n        children,\n        React.createElement(FieldDefinitionContext.Provider, { value: setFields }, finalContent)));\n};\nexport function Importer(_a) {\n    var { chunkSize, assumeNoHeaders, restartable, processChunk, onStart, onUpload, onComplete, onClose, children: content } = _a, customPapaParseConfig = __rest(_a, [\"chunkSize\", \"assumeNoHeaders\", \"restartable\", \"processChunk\", \"onStart\", \"onUpload\", \"onComplete\", \"onClose\", \"children\"]);\n    // helper to combine our displayed content and the user code that provides field definitions\n    const [fields, setFields] = useState([]);\n    const [selectedFile, setSelectedFile] = useState(null);\n    const [preview, setPreview] = useState(null);\n    const [formatAccepted, setFormatAccepted] = useState(false);\n    const [fieldAssignments, setFieldAssignments] = useState(null);\n    const fileHandler = useCallback((file) => {\n        if (onUpload) {\n            file = onUpload(file);\n        }\n        setSelectedFile(file);\n    }, []);\n    const externalPreview = useMemo(() => {\n        // generate stable externally-visible data objects\n        const externalColumns = preview && generatePreviewColumns(preview.firstRows, preview.hasHeaders);\n        return (preview &&\n            externalColumns && {\n            rawData: preview.firstChunk,\n            columns: externalColumns,\n            skipHeaders: !preview.hasHeaders,\n            parseWarning: preview.parseWarning\n        });\n    }, [preview]);\n    if (selectedFile === null) {\n        return (React.createElement(ContentWrapper, { setFields: setFields, preview: preview, externalPreview: externalPreview, content: content },\n            React.createElement(FileSelector, { onSelected: fileHandler })));\n    }\n    if (!formatAccepted || preview === null || externalPreview === null) {\n        return (React.createElement(ContentWrapper, { setFields: setFields, preview: preview, externalPreview: externalPreview, content: content },\n            React.createElement(FormatPreview, { customConfig: customPapaParseConfig, file: selectedFile, assumeNoHeaders: assumeNoHeaders, currentPreview: preview, onChange: (parsedPreview) => {\n                    setPreview(parsedPreview);\n                }, onAccept: () => {\n                    setFormatAccepted(true);\n                }, onCancel: () => {\n                    setSelectedFile(null);\n                    setPreview(null);\n                } })));\n    }\n    if (fieldAssignments === null) {\n        return (React.createElement(ContentWrapper, { setFields: setFields, preview: preview, externalPreview: externalPreview, content: content },\n            React.createElement(ColumnPicker, { fields: fields, preview: preview, onAccept: (assignments) => {\n                    setFieldAssignments(assignments);\n                }, onCancel: () => {\n                    // keep existing preview data\n                    setFormatAccepted(false);\n                } })));\n    }\n    return (React.createElement(ContentWrapper, { setFields: setFields, preview: preview, externalPreview: externalPreview, content: content },\n        React.createElement(ProgressDisplay, { preview: preview, externalPreview: externalPreview, fieldAssignments: fieldAssignments, chunkSize: chunkSize, processChunk: processChunk, onStart: onStart, onRestart: restartable\n                ? () => {\n                    // reset all state\n                    setSelectedFile(null);\n                    setPreview(null);\n                    setFormatAccepted(false);\n                    setFieldAssignments(null);\n                }\n                : undefined, onComplete: onComplete, onClose: onClose })));\n}\n","export * from './components/ImporterProps';\nexport * from './components/Importer';\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACrIA;AACA;AACA;AACA;AACA;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnIA;AACA;;;;A","sourceRoot":""}